Implement a hierarchical data structure consisting of two types of
node, file and directory.

Directories are represented as a BTreeMap<String, NodeID> for efficient lookups.

Files are immutable Vec<u8> values.

Because the data structure resembles a file system, it will be denoted
"FS".

Both files and directories will implement the Node trait. The FS will
be represented by a Vec<Rc<RefCell<Box<dyn Node>>>>, and nodes can
be borrowed using type NodeID(usize).

To refer to locations in the data structure the std::path::Path type.
Path components of this type have type OsStr, but they can safely be
assumed as valid UTF-8. Conversions to String are non-lossy for path
components.

To resolve a path:

- The path should not be empty, it must have one or more components.
- Considering the std::path::Component enum, only the Normal component type is considered valid.
- Paths are resolved relative to the root of the file system, so the RootDir component is optional and should be stripped.
- If the path has zero components after processing, it's an error - paths must have at least one component.
- Otherwise, use a recursive algorithm to resolve the path starting at the root:
  - If the path has more than one component, the leading component has to refer to a directory or else there is an error; if a matching directory is found, recursively resolve the remaining elements
  - If the path has one component, resolve the name to a handle and call caller-supplied function to operate on the handle with the enclosing directory context.

The enclosing directory context is referred to as the working
directory, noted "WD". The working directory consists of the NodeID
of the directory and the `&mut FS` reference, this is passed to the
caller-supplied function after the path is resolved.

A file system handle, denoted "Handle", comes in two variants:
- Handle::Found(NodeID) - contains the resolved node ID if the final path entry was found
- Handle::NotFound(String) - contains the name that was not found in the directory

To access or modify the file system, a functional approach is used with
an in_path method that takes a path and a closure to operate on the resolved
path. The closure receives a mutable reference to the working directory context
and the Handle. For example, to create a file in an already-existing directory:
```
  let result = fs.in_path("/directory/newfile", |wd, entry| {
    assert!(entry.is_none());
    entry.create_file("new file content")?;
    call_that_returns_result_of_T()
  })?;
```

The implementation includes various error types such as NotFound, NotADirectory, 
InvalidPath, and AlreadyExists that are returned as part of the Result type
when operations cannot be completed.
